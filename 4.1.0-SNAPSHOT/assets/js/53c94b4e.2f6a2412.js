"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[1936],{9898:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"server/instance-registry","title":"Instance Registry","description":"The Instance Registry is the core component responsible for managing registered applications in Spring Boot Admin. It","source":"@site/docs/02-server/40-instance-registry.md","sourceDirName":"02-server","slug":"/server/instance-registry","permalink":"/4.1.0-SNAPSHOT/docs/server/instance-registry","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":40,"frontMatter":{"sidebar_position":40,"sidebar_custom_props":{"icon":"apps"}},"sidebar":"sidebar","previous":{"title":"Persistence and Event Store","permalink":"/4.1.0-SNAPSHOT/docs/server/persistence"},"next":{"title":"Notifications","permalink":"/4.1.0-SNAPSHOT/docs/server/notifications/"}}');var i=t(4848),r=t(8453);const a={sidebar_position:40,sidebar_custom_props:{icon:"apps"}},c="Instance Registry",o={},l=[{value:"InstanceRepository",id:"instancerepository",level:2},{value:"Event-Sourced Implementation",id:"event-sourced-implementation",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Benefits of Event Sourcing",id:"benefits-of-event-sourcing",level:3},{value:"Instance Lifecycle",id:"instance-lifecycle",level:2},{value:"1. Registration",id:"1-registration",level:3},{value:"2. Endpoint Detection",id:"2-endpoint-detection",level:3},{value:"3. Status Updates",id:"3-status-updates",level:3},{value:"4. Info Updates",id:"4-info-updates",level:3},{value:"5. Deregistration",id:"5-deregistration",level:3},{value:"Optimistic Locking",id:"optimistic-locking",level:2},{value:"Querying Instances",id:"querying-instances",level:2},{value:"Find All Instances",id:"find-all-instances",level:3},{value:"Find by Instance ID",id:"find-by-instance-id",level:3},{value:"Find by Application Name",id:"find-by-application-name",level:3},{value:"Compute Operations",id:"compute-operations",level:2},{value:"compute()",id:"compute",level:3},{value:"computeIfPresent()",id:"computeifpresent",level:3},{value:"Instance State",id:"instance-state",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Instance ID Generation",id:"instance-id-generation",level:2},{value:"Default: HashingInstanceUrlIdGenerator",id:"default-hashinginstanceurlidgenerator",level:3},{value:"Cloud Foundry: CloudFoundryInstanceIdGenerator",id:"cloud-foundry-cloudfoundryinstanceidgenerator",level:3},{value:"Custom ID Generator",id:"custom-id-generator",level:3},{value:"Working with the Repository",id:"working-with-the-repository",level:2},{value:"Injecting the Repository",id:"injecting-the-repository",level:3},{value:"Reacting to Changes",id:"reacting-to-changes",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"instance-registry",children:"Instance Registry"})}),"\n",(0,i.jsxs)(n.p,{children:["The Instance Registry is the core component responsible for managing registered applications in Spring Boot Admin. It\nuses an event-sourced architecture to track application state through the ",(0,i.jsx)(n.code,{children:"InstanceRepository"})," interface."]}),"\n",(0,i.jsx)(n.h2,{id:"instancerepository",children:"InstanceRepository"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"InstanceRepository"})," is the primary interface for storing and retrieving application instances. It provides reactive\nmethods for managing instance lifecycle:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public interface InstanceRepository {\n\n    Mono<Instance> save(Instance app);\n\n    Flux<Instance> findAll();\n\n    Mono<Instance> find(InstanceId id);\n\n    Flux<Instance> findByName(String name);\n\n    Mono<Instance> compute(InstanceId id,\n        BiFunction<InstanceId, Instance, Mono<Instance>> remappingFunction);\n\n    Mono<Instance> computeIfPresent(InstanceId id,\n        BiFunction<InstanceId, Instance, Mono<Instance>> remappingFunction);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"event-sourced-implementation",children:"Event-Sourced Implementation"}),"\n",(0,i.jsxs)(n.p,{children:["Spring Boot Admin uses ",(0,i.jsx)(n.code,{children:"EventsourcingInstanceRepository"}),", which rebuilds instance state from events stored in the\n",(0,i.jsx)(n.code,{children:"InstanceEventStore"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsx)(n.p,{children:"Instead of directly storing instance state, the repository stores events that represent state changes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Registration"}),": When an application registers, an ",(0,i.jsx)(n.code,{children:"InstanceRegisteredEvent"})," is created"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Changes"}),": Each state change (health, info, endpoints) generates a new event"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reconstruction"}),": The current instance state is rebuilt by replaying all events"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class EventsourcingInstanceRepository implements InstanceRepository {\n\n    private final InstanceEventStore eventStore;\n\n    @Override\n    public Mono<Instance> save(Instance instance) {\n        return eventStore.append(instance.getUnsavedEvents())\n                        .then(Mono.just(instance.clearUnsavedEvents()));\n    }\n\n    @Override\n    public Mono<Instance> find(InstanceId id) {\n        return eventStore.find(id)\n                        .collectList()\n                        .filter(e -> !e.isEmpty())\n                        .map(events -> Instance.create(id).apply(events));\n    }\n\n    @Override\n    public Flux<Instance> findAll() {\n        return eventStore.findAll()\n                        .groupBy(InstanceEvent::getInstance)\n                        .flatMap(f -> f.reduce(Instance.create(f.key()),\n                                              Instance::apply));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-event-sourcing",children:"Benefits of Event Sourcing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complete Audit Trail"}),": Every change is recorded as an event"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Temporal Queries"}),": Can reconstruct state at any point in time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Replay"}),": Can rebuild state from events after crashes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debugging"}),": Full history of state changes for troubleshooting"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"instance-lifecycle",children:"Instance Lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"1-registration",children:"1. Registration"}),"\n",(0,i.jsx)(n.p,{children:"When an application registers, a new instance is created:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"InstanceId id = idGenerator.generateId(registration);\nInstance newInstance = Instance.create(id).register(registration);\nrepository.save(newInstance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates an ",(0,i.jsx)(n.code,{children:"InstanceRegisteredEvent"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"2-endpoint-detection",children:"2. Endpoint Detection"}),"\n",(0,i.jsx)(n.p,{children:"After registration, the server detects available actuator endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"instance = instance.withEndpoints(detectedEndpoints);\nrepository.save(instance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates an ",(0,i.jsx)(n.code,{children:"InstanceEndpointsDetectedEvent"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"3-status-updates",children:"3. Status Updates"}),"\n",(0,i.jsx)(n.p,{children:"The server periodically polls health endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"instance = instance.withStatusInfo(statusInfo);\nrepository.save(instance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates an ",(0,i.jsx)(n.code,{children:"InstanceStatusChangedEvent"})," when status changes."]}),"\n",(0,i.jsx)(n.h3,{id:"4-info-updates",children:"4. Info Updates"}),"\n",(0,i.jsx)(n.p,{children:"Application info is periodically refreshed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"instance = instance.withInfo(info);\nrepository.save(instance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates an ",(0,i.jsx)(n.code,{children:"InstanceInfoChangedEvent"})," when info changes."]}),"\n",(0,i.jsx)(n.h3,{id:"5-deregistration",children:"5. Deregistration"}),"\n",(0,i.jsx)(n.p,{children:"When an application shuts down or is removed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"instance = instance.deregister();\nrepository.save(instance);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generates an ",(0,i.jsx)(n.code,{children:"InstanceDeregisteredEvent"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"optimistic-locking",children:"Optimistic Locking"}),"\n",(0,i.jsx)(n.p,{children:"The repository uses optimistic locking to handle concurrent updates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'private final Retry retryOptimisticLockException = Retry.max(10)\n    .doBeforeRetry(s -> log.debug("Retrying after OptimisticLockingException",\n                                  s.failure()))\n    .filter(OptimisticLockingException.class::isInstance);\n\n@Override\npublic Mono<Instance> compute(InstanceId id,\n        BiFunction<InstanceId, Instance, Mono<Instance>> remappingFunction) {\n    return find(id)\n        .flatMap(app -> remappingFunction.apply(id, app))\n        .switchIfEmpty(Mono.defer(() -> remappingFunction.apply(id, null)))\n        .flatMap(this::save)\n        .retryWhen(retryOptimisticLockException);\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"If two updates conflict (based on event version numbers), the operation is automatically retried up to 10 times."}),"\n",(0,i.jsx)(n.h2,{id:"querying-instances",children:"Querying Instances"}),"\n",(0,i.jsx)(n.h3,{id:"find-all-instances",children:"Find All Instances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Flux<Instance> instances = repository.findAll();\ninstances.subscribe(instance -> {\n    System.out.println("Instance: " + instance.getRegistration().getName());\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"find-by-instance-id",children:"Find by Instance ID"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Mono<Instance> instance = repository.find(instanceId);\ninstance.subscribe(inst -> {\n    System.out.println("Found: " + inst.getRegistration().getName());\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"find-by-application-name",children:"Find by Application Name"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Flux<Instance> instances = repository.findByName("my-application");\ninstances.subscribe(instance -> {\n    System.out.println("Instance ID: " + instance.getId());\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"compute-operations",children:"Compute Operations"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"compute"})," methods provide atomic read-modify-write operations:"]}),"\n",(0,i.jsx)(n.h3,{id:"compute",children:"compute()"}),"\n",(0,i.jsx)(n.p,{children:"Updates an instance or creates it if it doesn't exist:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"repository.compute(instanceId, (id, instance) -> {\n    if (instance == null) {\n        // Create new instance\n        return Mono.just(Instance.create(id).register(registration));\n    } else {\n        // Update existing instance\n        return Mono.just(instance.withStatusInfo(newStatus));\n    }\n}).subscribe();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"computeifpresent",children:"computeIfPresent()"}),"\n",(0,i.jsx)(n.p,{children:"Updates only if the instance exists:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"repository.computeIfPresent(instanceId, (id, instance) -> {\n    return Mono.just(instance.withInfo(updatedInfo));\n}).subscribe();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"instance-state",children:"Instance State"}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.code,{children:"Instance"})," object contains:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class Instance {\n    private final InstanceId id;\n    private final long version;\n    private final Registration registration;\n    private final boolean registered;\n    private final StatusInfo statusInfo;\n    private final Info info;\n    private final Endpoints endpoints;\n    private final BuildVersion buildVersion;\n    private final Tags tags;\n    private final List<InstanceEvent> unsavedEvents;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"id"})}),": Unique identifier for the instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"version"})}),": Event version for optimistic locking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"registration"})}),": Registration details (name, URL, metadata)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"registered"})}),": Whether the instance is currently registered"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"statusInfo"})}),": Current health status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"info"})}),": Application info from ",(0,i.jsx)(n.code,{children:"/actuator/info"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"endpoints"})}),": Discovered actuator endpoints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"buildVersion"})}),": Application version from build-info"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"tags"})}),": Custom tags for classification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"unsavedEvents"})}),": Events pending persistence"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"instance-id-generation",children:"Instance ID Generation"}),"\n",(0,i.jsxs)(n.p,{children:["Instance IDs are generated by ",(0,i.jsx)(n.code,{children:"InstanceIdGenerator"})," implementations:"]}),"\n",(0,i.jsx)(n.h3,{id:"default-hashinginstanceurlidgenerator",children:"Default: HashingInstanceUrlIdGenerator"}),"\n",(0,i.jsx)(n.p,{children:"Generates stable IDs based on the service URL:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class HashingInstanceUrlIdGenerator implements InstanceIdGenerator {\n    @Override\n    public InstanceId generateId(Registration registration) {\n        String serviceUrl = registration.getServiceUrl();\n        // Generate hash-based ID from URL\n        return InstanceId.of(hash(serviceUrl));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"cloud-foundry-cloudfoundryinstanceidgenerator",children:"Cloud Foundry: CloudFoundryInstanceIdGenerator"}),"\n",(0,i.jsx)(n.p,{children:"Uses Cloud Foundry's application instance ID:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class CloudFoundryInstanceIdGenerator implements InstanceIdGenerator {\n    @Override\n    public InstanceId generateId(Registration registration) {\n        String cfInstanceId = registration.getMetadata()\n                                         .get("applicationId")\n            + ":" + registration.getMetadata().get("instanceId");\n        return InstanceId.of(cfInstanceId);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-id-generator",children:"Custom ID Generator"}),"\n",(0,i.jsx)(n.p,{children:"Implement your own ID generation strategy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\npublic class CustomInstanceIdGenerator implements InstanceIdGenerator {\n\n    @Override\n    public InstanceId generateId(Registration registration) {\n        // Custom logic to generate instance ID\n        String customId = registration.getName()\n            + "-" + UUID.randomUUID().toString();\n        return InstanceId.of(customId);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"working-with-the-repository",children:"Working with the Repository"}),"\n",(0,i.jsx)(n.h3,{id:"injecting-the-repository",children:"Injecting the Repository"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Component\npublic class InstanceManager {\n\n    private final InstanceRepository repository;\n\n    public InstanceManager(InstanceRepository repository) {\n        this.repository = repository;\n    }\n\n    public Flux<String> getApplicationNames() {\n        return repository.findAll()\n                        .filter(Instance::isRegistered)\n                        .map(i -> i.getRegistration().getName())\n                        .distinct();\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"reacting-to-changes",children:"Reacting to Changes"}),"\n",(0,i.jsx)(n.p,{children:"Subscribe to the event store to react to instance changes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\npublic class InstanceChangeListener {\n\n    public InstanceChangeListener(InstanceEventStore eventStore,\n                                  InstanceRepository repository) {\n        eventStore.subscribe(event -> {\n            if (event instanceof InstanceStatusChangedEvent statusEvent) {\n                repository.find(event.getInstance())\n                         .subscribe(instance -> {\n                             log.info("Instance {} status: {}",\n                                     instance.getRegistration().getName(),\n                                     instance.getStatusInfo().getStatus());\n                         });\n            }\n        });\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use compute methods"})," for atomic updates to avoid race conditions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Don't modify Instance objects directly"})," - use the builder-style methods (withXxx)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Let the system retry"})," optimistic locking failures automatically"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscribe to events"})," for reactive processing instead of polling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use findByName"})," for multi-instance applications to find all instances of a service"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/persistence",children:"Persistence"})," - Learn about event storage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/Events",children:"Events"})," - Understand the event system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/Clustering",children:"Clustering"})," - Distributed instance management"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);