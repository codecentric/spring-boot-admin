"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[3740],{4767:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"server/persistence","title":"Persistence and Event Store","description":"Spring Boot Admin uses an event-sourced architecture to track the state of registered applications. All changes to","source":"@site/docs/02-server/30-persistence.md","sourceDirName":"02-server","slug":"/server/persistence","permalink":"/4.1.0-SNAPSHOT/docs/server/persistence","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"sidebar_custom_props":{"icon":"database"}},"sidebar":"sidebar","previous":{"title":"Clustering","permalink":"/4.1.0-SNAPSHOT/docs/server/Clustering"},"next":{"title":"Instance Registry","permalink":"/4.1.0-SNAPSHOT/docs/server/instance-registry"}}');var i=t(4848),r=t(8453);const a={sidebar_position:30,sidebar_custom_props:{icon:"database"}},c="Persistence and Event Store",o={},l=[{value:"Event Store Architecture",id:"event-store-architecture",level:2},{value:"InMemoryEventStore",id:"inmemoryeventstore",level:3},{value:"HazelcastEventStore",id:"hazelcasteventstore",level:3},{value:"Event Types",id:"event-types",level:2},{value:"InstanceEventStore Interface",id:"instanceeventstore-interface",level:2},{value:"Methods",id:"methods",level:3},{value:"Event Versioning and Optimistic Locking",id:"event-versioning-and-optimistic-locking",level:2},{value:"Event Publishing",id:"event-publishing",level:2},{value:"Configuring Event Store Size",id:"configuring-event-store-size",level:2},{value:"Custom Event Store Implementation",id:"custom-event-store-implementation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Monitoring Event Store",id:"monitoring-event-store",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"persistence-and-event-store",children:"Persistence and Event Store"})}),"\n",(0,i.jsxs)(n.p,{children:["Spring Boot Admin uses an event-sourced architecture to track the state of registered applications. All changes to\napplication instances are stored as events in an ",(0,i.jsx)(n.code,{children:"InstanceEventStore"}),", allowing the server to rebuild application state\nand maintain a complete audit trail."]}),"\n",(0,i.jsx)(n.h2,{id:"event-store-architecture",children:"Event Store Architecture"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"InstanceEventStore"})," is responsible for storing all instance-related events. Spring Boot Admin provides two built-in\nimplementations:"]}),"\n",(0,i.jsx)(n.h3,{id:"inmemoryeventstore",children:"InMemoryEventStore"}),"\n",(0,i.jsxs)(n.p,{children:["The default implementation stores events in memory using a ",(0,i.jsx)(n.code,{children:"ConcurrentHashMap"}),". This is suitable for single-instance\ndeployments and development environments."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast and lightweight"}),"\n",(0,i.jsx)(n.li,{children:"Non-persistent (data lost on restart)"}),"\n",(0,i.jsx)(n.li,{children:"Limited by available memory"}),"\n",(0,i.jsx)(n.li,{children:"Configurable maximum log size per instance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Bean\npublic InstanceEventStore eventStore() {\n    return new InMemoryEventStore(100); // Max 100 events per instance\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The default configuration creates an ",(0,i.jsx)(n.code,{children:"InMemoryEventStore"})," with a maximum of 100 events per instance aggregate. Older\nevents are automatically removed when the limit is reached."]}),"\n",(0,i.jsx)(n.h3,{id:"hazelcasteventstore",children:"HazelcastEventStore"}),"\n",(0,i.jsxs)(n.p,{children:["For clustered deployments, the ",(0,i.jsx)(n.code,{children:"HazelcastEventStore"})," provides distributed persistence using Hazelcast's ",(0,i.jsx)(n.code,{children:"IMap"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Characteristics:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Distributed across cluster nodes"}),"\n",(0,i.jsx)(n.li,{children:"Survives single-node failures"}),"\n",(0,i.jsx)(n.li,{children:"Automatic synchronization between nodes"}),"\n",(0,i.jsx)(n.li,{children:"Real-time event publishing across the cluster"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Configuration:"})}),"\n",(0,i.jsx)(n.p,{children:"First, add the Hazelcast dependency:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",metastring:'title="pom.xml"',children:"<dependency>\n    <groupId>com.hazelcast</groupId>\n    <artifactId>hazelcast</artifactId>\n</dependency>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then configure the Hazelcast-backed event store:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.map.IMap;\nimport de.codecentric.boot.admin.server.eventstore.HazelcastEventStore;\n\n@Configuration\npublic class HazelcastConfig {\n\n    @Bean\n    public Config hazelcastConfig() {\n        MapConfig mapConfig = new MapConfig("spring-boot-admin-event-store")\n            .setBackupCount(1)\n            .setMergePolicyConfig(new MergePolicyConfig(\n                PutIfAbsentMergePolicy.class.getName(), 100));\n\n        Config config = new Config();\n        config.addMapConfig(mapConfig);\n        return config;\n    }\n\n    @Bean\n    public HazelcastInstance hazelcastInstance(Config hazelcastConfig) {\n        return Hazelcast.newHazelcastInstance(hazelcastConfig);\n    }\n\n    @Bean\n    public InstanceEventStore eventStore(HazelcastInstance hazelcastInstance) {\n        IMap<InstanceId, List<InstanceEvent>> map =\n            hazelcastInstance.getMap("spring-boot-admin-event-store");\n        return new HazelcastEventStore(100, map);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"HazelcastEventStore"})," listens to map entry updates and publishes new events to all cluster nodes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"eventLog.addEntryListener(new EntryAdapter<InstanceId, List<InstanceEvent>>() {\n    @Override\n    public void entryUpdated(EntryEvent<InstanceId, List<InstanceEvent>> event) {\n        long lastKnownVersion = getLastVersion(event.getOldValue());\n        List<InstanceEvent> newEvents = event.getValue()\n            .stream()\n            .filter((e) -> e.getVersion() > lastKnownVersion)\n            .toList();\n        publish(newEvents);\n    }\n}, true);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"event-types",children:"Event Types"}),"\n",(0,i.jsx)(n.p,{children:"The event store manages different types of instance events:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceRegisteredEvent"})," - Application registers with the server"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceDeregisteredEvent"})," - Application unregisters or is removed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceStatusChangedEvent"})," - Health status changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceEndpointsDetectedEvent"})," - Actuator endpoints discovered"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceInfoChangedEvent"})," - Application info updated"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InstanceRegistrationUpdatedEvent"})," - Registration details changed"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each event contains:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Instance ID"}),"\n",(0,i.jsx)(n.li,{children:"Timestamp"}),"\n",(0,i.jsx)(n.li,{children:"Version (for optimistic locking)"}),"\n",(0,i.jsx)(n.li,{children:"Event-specific data"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"instanceeventstore-interface",children:"InstanceEventStore Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public interface InstanceEventStore extends Publisher<InstanceEvent> {\n\n    Flux<InstanceEvent> findAll();\n\n    Flux<InstanceEvent> find(InstanceId id);\n\n    Mono<Void> append(List<InstanceEvent> events);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"methods",children:"Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"findAll()"})})," - Returns all events for all instances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"find(InstanceId id)"})})," - Returns events for a specific instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"append(List<InstanceEvent> events)"})})," - Appends new events to the store"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The store also implements ",(0,i.jsx)(n.code,{children:"Publisher<InstanceEvent>"}),", allowing components to subscribe to new events in real-time."]}),"\n",(0,i.jsx)(n.h2,{id:"event-versioning-and-optimistic-locking",children:"Event Versioning and Optimistic Locking"}),"\n",(0,i.jsx)(n.p,{children:"Events are versioned to prevent concurrent modification issues. Each event includes a version number that increments\nwith each change:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public abstract class InstanceEvent implements Serializable {\n    private final InstanceId instance;\n    private final long version;\n    private final long timestamp;\n\n    // ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When appending events, the event store checks that the version matches the expected sequence, throwing an\n",(0,i.jsx)(n.code,{children:"OptimisticLockingException"})," if there's a conflict."]}),"\n",(0,i.jsx)(n.h2,{id:"event-publishing",children:"Event Publishing"}),"\n",(0,i.jsx)(n.p,{children:"The event store publishes events to subscribers, enabling reactive processing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'eventStore.subscribe(event -> {\n    if (event instanceof InstanceStatusChangedEvent statusEvent) {\n        // React to status changes\n        System.out.println("Instance " + event.getInstance() +\n                          " changed to " + statusEvent.getStatusInfo().getStatus());\n    }\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuring-event-store-size",children:"Configuring Event Store Size"}),"\n",(0,i.jsx)(n.p,{children:"Control the maximum number of events stored per instance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Bean\npublic InstanceEventStore eventStore() {\n    return new InMemoryEventStore(500); // Store up to 500 events per instance\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"When the limit is reached, the oldest events are removed. This prevents unbounded memory growth while maintaining recent\nhistory."}),"\n",(0,i.jsx)(n.h2,{id:"custom-event-store-implementation",children:"Custom Event Store Implementation"}),"\n",(0,i.jsx)(n.p,{children:"You can implement your own event store for custom persistence requirements (e.g., database, external cache):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class CustomEventStore implements InstanceEventStore {\n\n    @Override\n    public Flux<InstanceEvent> findAll() {\n        // Load all events from your storage\n    }\n\n    @Override\n    public Flux<InstanceEvent> find(InstanceId id) {\n        // Load events for specific instance\n    }\n\n    @Override\n    public Mono<Void> append(List<InstanceEvent> events) {\n        // Persist events and publish to subscribers\n    }\n\n    @Override\n    public void subscribe(Subscriber<? super InstanceEvent> subscriber) {\n        // Handle event subscriptions\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then register your custom implementation as a bean:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Bean\npublic InstanceEventStore eventStore() {\n    return new CustomEventStore();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Development"}),": Use ",(0,i.jsx)(n.code,{children:"InMemoryEventStore"})," for simplicity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Single Instance Deployments"}),": Use ",(0,i.jsx)(n.code,{children:"InMemoryEventStore"})," if restart data loss is acceptable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Clustered Deployments"}),": Use ",(0,i.jsx)(n.code,{children:"HazelcastEventStore"})," for high availability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Large Deployments"}),": Tune the max log size to balance memory usage and history retention"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"For Custom Requirements"}),": Implement your own event store with database or distributed cache backing"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"monitoring-event-store",children:"Monitoring Event Store"}),"\n",(0,i.jsx)(n.p,{children:"Monitor event store health through actuator endpoints or by subscribing to events:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\npublic class EventStoreMonitor {\n\n    public EventStoreMonitor(InstanceEventStore eventStore) {\n        eventStore.subscribe(event -> {\n            // Log or metric collection\n            log.debug("Event: {} for instance {}",\n                     event.getType(), event.getInstance());\n        });\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/Clustering",children:"Clustering"})," - Learn about clustering with Hazelcast"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/Events",children:"Events"})," - Understand the event system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/4.1.0-SNAPSHOT/docs/server/instance-registry",children:"Instance Registry"})," - How instances are managed"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);